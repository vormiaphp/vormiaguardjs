{"version":3,"file":"svelte.js","sources":["../../../src/adapters/svelte/vormiaStore.js"],"sourcesContent":["import { writable } from 'svelte/store';\nimport { getGlobalVormiaClient } from '../../client/createVormiaClient';\nimport { VormiaError } from '../../client/utils/VormiaError';\n\nexport function createVormiaStore(initialOptions = {}) {\n  const client = getGlobalVormiaClient();\n  const { subscribe, set, update } = writable({\n    data: null,\n    error: null,\n    isLoading: false,\n    isError: false,\n    isSuccess: false,\n  });\n\n  async function fetchData(options = {}) {\n    const mergedOptions = { ...initialOptions, ...options };\n    const { \n      endpoint, \n      method = 'GET', \n      params, \n      data: bodyData, \n      headers, \n      transform, \n      onSuccess, \n      onError \n    } = mergedOptions;\n\n    update(state => ({ ...state, isLoading: true, isError: false, isSuccess: false }));\n\n    try {\n      const config = {\n        method,\n        params: method === 'GET' ? params : undefined,\n        data: method !== 'GET' ? (bodyData || params) : undefined,\n        headers\n      };\n\n      const response = await client.request({\n        url: endpoint,\n        ...config\n      });\n\n      let result = response.data;\n\n      if (transform) {\n        result = transform(result);\n      }\n\n      const newState = {\n        data: result,\n        error: null,\n        isLoading: false,\n        isError: false,\n        isSuccess: true\n      };\n\n      set(newState);\n      \n      if (onSuccess) {\n        onSuccess(newState);\n      }\n\n      return newState;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';\n      const status = err?.response?.status;\n      const errorData = err?.response?.data;\n      \n      const errorObj = err instanceof VormiaError \n        ? err \n        : new VormiaError(errorMessage, status, errorData);\n\n      const errorState = {\n        data: null,\n        error: errorObj,\n        isLoading: false,\n        isError: true,\n        isSuccess: false\n      };\n\n      set(errorState);\n      \n      if (onError) {\n        onError(errorObj);\n      }\n\n      throw errorObj;\n    }\n  }\n\n  if (initialOptions.immediate !== false) {\n    fetchData();\n  }\n\n  return {\n    subscribe,\n    fetch: fetchData,\n    refetch: fetchData,\n    set,\n    update\n  };\n}\n"],"names":["initialOptions","client","getGlobalVormiaClient","subscribe","set","update","writable","data","error","isLoading","isError","isSuccess","async","fetchData","options","mergedOptions","endpoint","method","params","bodyData","headers","transform","onSuccess","onError","state","config","result","request","url","newState","err","errorMessage","Error","message","status","_a","response","errorData","_b","errorObj","VormiaError","immediate","fetch","refetch"],"mappings":"mOAIO,SAA2BA,EAAiB,IACjD,MAAMC,EAASC,EAAAA,yBACTC,UAAEA,EAAAC,IAAWA,EAAAC,OAAKA,GAAWC,EAAAA,SAAS,CAC1CC,KAAM,KACNC,MAAO,KACPC,WAAW,EACXC,SAAS,EACTC,WAAW,IAGbC,eAAeC,EAAUC,EAAU,YACjC,MAAMC,EAAgB,IAAKf,KAAmBc,IACxCE,SACJA,EAAAC,OACAA,EAAS,MAAAC,OACTA,EACAX,KAAMY,EAAAC,QACNA,EAAAC,UACAA,EAAAC,UACAA,EAAAC,QACAA,GACER,EAEJV,EAAOmB,IAAA,IAAeA,EAAOf,WAAW,EAAMC,SAAS,EAAOC,WAAW,KAEzE,IACE,MAAMc,EAAS,CACbR,SACAC,OAAmB,QAAXD,EAAmBC,OAAS,EACpCX,KAAiB,QAAXU,EAAoBE,GAAYD,OAAU,EAChDE,WAQF,IAAIM,SALmBzB,EAAO0B,QAAQ,CACpCC,IAAKZ,KACFS,KAGiBlB,KAElBc,IACFK,EAASL,EAAUK,IAGrB,MAAMG,EAAW,CACftB,KAAMmB,EACNlB,MAAO,KACPC,WAAW,EACXC,SAAS,EACTC,WAAW,GASb,OANAP,EAAIyB,GAEAP,GACFA,EAAUO,GAGLA,CACb,OAAaC,GACP,MAAMC,EAAeD,aAAeE,MAAQF,EAAIG,QAAU,4BACpDC,EAAS,OAAAC,EAAA,MAAAL,OAAA,EAAAA,EAAKM,eAAL,EAAAD,EAAeD,OACxBG,EAAY,OAAAC,EAAA,MAAAR,OAAA,EAAAA,EAAKM,eAAL,EAAAE,EAAe/B,KAE3BgC,EAAWT,aAAeU,EAAAA,YAC5BV,EACA,IAAIU,cAAYT,EAAcG,EAAQG,GAgB1C,MANAjC,EARmB,CACjBG,KAAM,KACNC,MAAO+B,EACP9B,WAAW,EACXC,SAAS,EACTC,WAAW,IAKTY,GACFA,EAAQgB,GAGJA,CACZ,CACA,CAME,OAJiC,IAA7BvC,EAAeyC,WACjB5B,IAGK,CACLV,YACAuC,MAAO7B,EACP8B,QAAS9B,EACTT,MACAC,SAEJ"}