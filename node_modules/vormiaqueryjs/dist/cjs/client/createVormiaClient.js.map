{"version":3,"file":"createVormiaClient.js","sources":["../../../src/client/createVormiaClient.js"],"sourcesContent":["import {\n  encryptData,\n  encryptWithPublicKey,\n  decryptWithPrivateKey,\n} from \"./utils/encryption.js\";\n\n/* global process */\n\n// Helper function to convert headers to HeadersInit\nconst toHeadersInit = (headers) => {\n  const result = {};\n  if (!headers) return result;\n\n  Object.entries(headers).forEach(([key, value]) => {\n    if (Array.isArray(value)) {\n      result[key] = value.join(\",\");\n    } else if (value !== undefined) {\n      result[key] = value;\n    }\n  });\n\n  return result;\n};\n\n// Create a simple HTTP client that matches our VormiaInstance interface\nconst createHttpClient = (baseConfig) => {\n  const client = {\n    request: async (config) => {\n      const fullUrl = config.url\n        ? new URL(config.url, config.baseURL || baseConfig.baseURL).toString()\n        : \"\";\n      const headers = toHeadersInit({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...baseConfig.headers,\n        ...config.headers,\n      });\n\n      try {\n        const response = await fetch(fullUrl, {\n          method: config.method || \"GET\",\n          headers,\n          body: config.data ? JSON.stringify(config.data) : undefined,\n          credentials:\n            config.withCredentials || baseConfig.withCredentials\n              ? \"include\"\n              : \"same-origin\",\n        });\n\n        const responseData = await response.json().catch(() => ({}));\n\n        if (!response.ok) {\n          throw new Error(\n            JSON.stringify({\n              message: responseData.message || \"Request failed\",\n              status: response.status,\n              response: {\n                data: responseData,\n                status: response.status,\n                statusText: response.statusText,\n                headers: {},\n              },\n            })\n          );\n        }\n\n        return {\n          data: responseData,\n          status: response.status,\n          statusText: response.statusText,\n          headers: response.headers,\n          config,\n        };\n      } catch (error) {\n        let errorData;\n        try {\n          errorData = JSON.parse(error.message);\n        } catch {\n          errorData = {\n            message: error.message,\n            status: 0,\n            response: {\n              data: { message: error.message },\n              status: 0,\n              statusText: \"\",\n              headers: {},\n            },\n          };\n        }\n\n        const errorObj = new Error(errorData.message);\n        errorObj.status = errorData.status;\n        errorObj.response = errorData.response;\n        throw errorObj;\n      }\n    },\n  };\n\n  // Add HTTP methods\n  const methods = [\"get\", \"delete\", \"head\", \"options\"];\n  methods.forEach((method) => {\n    client[method] = (url, config = {}) =>\n      client.request({ ...config, method: method.toUpperCase(), url });\n  });\n\n  const methodsWithData = [\"post\", \"put\", \"patch\"];\n  methodsWithData.forEach((method) => {\n    client[method] = (url, data, config = {}) =>\n      client.request({\n        ...config,\n        method: method.toUpperCase(),\n        url,\n        data,\n      });\n  });\n\n  return client;\n};\n\nclass VormiaClient {\n  constructor(config) {\n    this.config = {\n      authTokenKey: \"auth_token\",\n      withCredentials: false,\n      timeout: 30000,\n      rsaEncrypt: false,\n      publicKey: process.env.VORMIA_PUBLIC_KEY,\n      privateKey: process.env.VORMIA_PRIVATE_KEY,\n      ...config,\n    };\n\n    this.http = createHttpClient({\n      baseURL: this.config.baseURL,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...this.config.headers,\n      },\n      withCredentials: this.config.withCredentials,\n      timeout: this.config.timeout,\n    });\n  }\n\n  // Simplified interceptor-like functionality\n  async handleRequest(config) {\n    // Add auth token if available\n    const token = this.getAuthToken();\n    if (token) {\n      config.headers = {\n        ...config.headers,\n        Authorization: `Bearer ${token}`,\n      };\n    }\n\n    // Handle encryption if enabled\n    if (config.encryptData && this.config.encryptionKey) {\n      if (config.data) {\n        config.data = {\n          encrypted: encryptData(\n            JSON.stringify(config.data),\n            this.config.encryptionKey\n          ),\n        };\n      }\n      if (config.params) {\n        config.params = {\n          encrypted: encryptData(\n            JSON.stringify(config.params),\n            this.config.encryptionKey\n          ),\n        };\n      }\n    }\n\n    return config;\n  }\n\n  handleUnauthorized() {\n    this.removeAuthToken();\n    if (this.config.onUnauthenticated) {\n      this.config.onUnauthenticated();\n    }\n  }\n\n  getAuthToken() {\n    if (typeof window !== \"undefined\") {\n      return localStorage.getItem(this.config.authTokenKey);\n    }\n    return null;\n  }\n\n  setAuthToken(token) {\n    if (typeof window !== \"undefined\") {\n      localStorage.setItem(this.config.authTokenKey, token);\n    }\n  }\n\n  removeAuthToken() {\n    if (typeof window !== \"undefined\") {\n      localStorage.removeItem(this.config.authTokenKey);\n    }\n  }\n\n  async request(config) {\n    try {\n      const processedConfig = await this.handleRequest({\n        ...config,\n        headers: {\n          ...this.config.headers,\n          ...config.headers,\n        },\n      });\n\n      // Encrypt request data if enabled\n      let requestData = processedConfig.data;\n      if (this.config.rsaEncrypt && requestData) {\n        requestData = encryptWithPublicKey(requestData, this.config.publicKey);\n        processedConfig.data = { encrypted: requestData };\n      }\n\n      const response = await this.http.request(processedConfig);\n\n      // Decrypt response data if enabled\n      let responseData = response.data;\n      if (this.config.rsaEncrypt && responseData && responseData.encrypted) {\n        responseData = decryptWithPrivateKey(\n          responseData.encrypted,\n          this.config.privateKey\n        );\n        response.data = responseData;\n      }\n      return response;\n    } catch (error) {\n      if (error.status === 401) {\n        this.handleUnauthorized();\n      }\n      throw error;\n    }\n  }\n\n  get(url, config) {\n    return this.request({ ...config, method: \"GET\", url });\n  }\n\n  post(url, data, config) {\n    return this.request({ ...config, method: \"POST\", url, data });\n  }\n\n  put(url, data, config) {\n    return this.request({ ...config, method: \"PUT\", url, data });\n  }\n\n  patch(url, data, config) {\n    return this.request({ ...config, method: \"PATCH\", url, data });\n  }\n\n  delete(url, config) {\n    return this.request({ ...config, method: \"DELETE\", url });\n  }\n}\n\n// Create and export the client factory function\nexport function createVormiaClient(config) {\n  return new VormiaClient(config);\n}\n\n// Global client instance\nlet globalClient = null;\n\nexport function setGlobalVormiaClient(client) {\n  globalClient = client;\n}\n\nexport function getGlobalVormiaClient() {\n  if (!globalClient) {\n    throw new Error(\n      \"Vormia client not initialized. Call createVormiaClient first.\"\n    );\n  }\n  return globalClient;\n}\n\nexport { VormiaClient };\n"],"names":["createHttpClient","baseConfig","client","request","async","config","fullUrl","url","URL","baseURL","toString","headers","result","Object","entries","forEach","key","value","Array","isArray","join","toHeadersInit","Accept","response","fetch","method","body","data","JSON","stringify","credentials","withCredentials","responseData","json","catch","ok","Error","message","status","statusText","error","errorData","parse","errorObj","toUpperCase","VormiaClient","constructor","this","authTokenKey","timeout","rsaEncrypt","publicKey","process","env","VORMIA_PUBLIC_KEY","privateKey","VORMIA_PRIVATE_KEY","http","handleRequest","token","getAuthToken","Authorization","encryptData","encryptionKey","encrypted","params","handleUnauthorized","removeAuthToken","onUnauthenticated","window","localStorage","getItem","setAuthToken","setItem","removeItem","processedConfig","requestData","encryptWithPublicKey","decryptWithPrivateKey","get","post","put","patch"],"mappings":"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"}